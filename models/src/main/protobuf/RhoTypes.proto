/**
 * Rholang Term Structure
 *
 * The top level is `Par`.
 *
 */
syntax = "proto3";

package rhoapi;

// If you are building for other languages "scalapb.proto"
// can be manually obtained here:
// https://raw.githubusercontent.com/scalapb/ScalaPB/master/protobuf/scalapb/scalapb.proto
// make a scalapb directory in this file's location and place it inside

import "scalapb/scalapb.proto";

option (scalapb.options) = {
  package_name: "coop.rchain.models"
  import: "coop.rchain.models.BitSetBytesMapper.bitSetBytesMapper"
  import: "coop.rchain.models.ParSetTypeMapper.parSetESetTypeMapper"
  import: "coop.rchain.models.ParMapTypeMapper.parMapEMapTypeMapper"
  preserve_unknown_fields: false
};

/**
 * Rholang process
 *
 * For example, `@0!(1) | @2!(3) | for(x <- @0) { Nil }` has two sends
 * and one receive.
 *
 * The Nil process is a `Par` with no sends, receives, etc.
 */
message Par {
  repeated Send sends = 1;
  repeated Receive receives = 2;
  repeated New news = 4;
  repeated Expr exprs = 5;
  repeated Match matches = 6;
  repeated GUnforgeable unforgeables = 7;  // unforgeable names
  repeated Bundle bundles = 11;
  repeated Connective connectives = 8;
  bytes locallyFree = 9
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 10;
  // UseBlock for scoped default space selection (Reifying RSpaces)
  repeated UseBlock use_blocks = 12;
}

/**
 * Either rholang code or code built in to the interpreter.
 */
message TaggedContinuation {
  oneof tagged_cont {
    ParWithRandom par_body = 1;
    int64 scala_body_ref = 2;
  }
}

/**
 * Rholang code along with the state of a split random number
 * generator for generating new unforgeable names.
 */
message ParWithRandom {
  Par body = 1 [(scalapb.field).no_box = true];
  bytes randomState = 2
      [(scalapb.field).type = "coop.rchain.crypto.hash.Blake2b512Random"];
}

/**
 * Cost of the performed operations.
 */
message PCost {
  uint64 cost = 1;
}

message ListParWithRandom {
  repeated Par pars = 1;
  bytes randomState = 2
      [(scalapb.field).type = "coop.rchain.crypto.hash.Blake2b512Random"];
}

// While we use vars in both positions, when producing the normalized
// representation we need a discipline to track whether a var is a name or a
// process.
// These are DeBruijn levels
message Var {
  message WildcardMsg {}
  oneof var_instance {
    sint32 bound_var = 1;
    sint32 free_var = 2;
    WildcardMsg wildcard = 3;
  }
}

/**
 * Nothing can be received from a (quoted) bundle with `readFlag = false`.
 * Likeise nothing can be sent to a (quoted) bundle with `writeFlag = false`.
 *
 * If both flags are set to false, bundle allows only for equivalance check.
 */
message Bundle {
  Par body = 1 [(scalapb.field).no_box = true];
  bool writeFlag = 2;  // flag indicating whether bundle is writeable
  bool readFlag = 3;   // flag indicating whether bundle is readable
}

/**
 * A send is written `chan!(data)` or `chan!!(data)` for a persistent send.
 *
 * Hyperparameters can be specified after data with semicolon separator:
 *   channel!(data; param1, param2)          - positional hyperparams
 *   channel!(data; priority=0, ttl=100)     - named hyperparams
 *   channel!(data; 0, ttl=100)              - mixed (positional first)
 *
 * Upon send, all free variables in data are substituted with their values.
 */
message Send {
  Par chan = 1 [(scalapb.field).no_box = true];
  repeated Par data = 2;
  bool persistent = 3;
  bytes locallyFree = 5
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 6;
  // Hyperparameters for space-specific behavior (priority, ttl, etc.)
  // Syntax: channel!(data; hyperparams)
  // Formal Correspondence: Collections/PriorityQueue.v (first positional = priority)
  repeated Hyperparam hyperparams = 8;
}

/**
 * Hyperparam - a hyperparameter for send operations.
 *
 * Hyperparameters allow space-specific behavior customization:
 *   - Positional: first positional is typically priority for PriorityQueue
 *   - Named: key=value pairs like priority=0, ttl=100
 *
 * Formal Correspondence: Collections/PriorityQueue.v
 */
message Hyperparam {
  oneof hyperparam_instance {
    Par positional = 1;              // Positional hyperparam (e.g., priority as first param)
    NamedHyperparam named = 2;       // Named hyperparam (key=value)
  }
}

/**
 * NamedHyperparam - a named key=value hyperparameter.
 */
message NamedHyperparam {
  string key = 1;
  Par value = 2 [(scalapb.field).no_box = true];
}

/**
 * ReceiveBind with optional pattern modifiers
 *
 * Pattern modifiers allow customizing the matching behavior in for-comprehensions.
 * They are represented as EFunction calls for extensibility.
 *
 * Syntax (compositional with ~ operator):
 *   for (resultCh <- ch ~ "query")                                      // Basic query (use space defaults)
 *   for (resultCh <- ch ~ sim("cos") ~ "query")                         // Explicit metric
 *   for (resultCh <- ch ~ sim("cos", "0.7") ~ "query")                  // Explicit metric and threshold
 *   for (resultCh <- ch ~ sim("boost", "0.7", "topic", 1.5) ~ "query")  // Extra params
 *   for (resultCh <- ch ~ rank("topk", 3) ~ "query")                    // Top-K results
 *   for (resultCh <- ch ~ rank("all") ~ "query")                        // All results
 *   for (resultCh <- ch ~ sim("cos", "0.7") ~ rank("topk", 3) ~ "q")    // Full composition
 *   for (resultCh <- ch ~ sim(@metric, @threshold) ~ @queryVec)         // Parameterized
 *
 * Available modifiers (as EFunction calls):
 *   sim(metric_id)                          - similarity metric only (use default threshold)
 *   sim(metric_id, threshold)               - metric with explicit threshold
 *   sim(metric_id, threshold, extra...)     - metric-specific extra hyperparameters
 *   rank(function_id)                       - ranking function (e.g., "all")
 *   rank(function_id, params...)            - ranking function with params (e.g., "topk", 3)
 *
 * Formal Correspondence: Collections/VectorDB.v (similarity_match)
 */
message ReceiveBind {
  repeated Par patterns = 1;
  Par source = 2 [(scalapb.field).no_box = true];
  Var remainder = 3;
  int32 freeCount = 4;
  // Pattern modifiers as generic EFunction calls (sim, rank, future: filter, weight, decay)
  // This replaces the previous SimilarityPattern field for extensibility.
  repeated EFunction pattern_modifiers = 5;
}

message BindPattern {
  repeated Par patterns = 1;
  Var remainder = 2;
  int32 freeCount = 3;
}

message ListBindPatterns {
  repeated BindPattern patterns = 1;
}

/**
 * A receive is written `for(binds) { body }`
 * i.e. `for(patterns <- source) { body }`
 * or for a persistent recieve: `for(patterns <= source) { body }`.
 *
 * It's an error for free Variable to occur more than once in a pattern.
 */
message Receive {
  repeated ReceiveBind binds = 1;
  Par body = 2 [(scalapb.field).no_box = true];
  bool persistent = 3;
  bool peek = 4;
  int32 bindCount = 5;
  bytes locallyFree = 6
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 7;
}

// Number of variables bound in the new statement.
// For normalized form, p should not contain solely another new.
// Also for normalized form, the first use should be level+0, next use level+1
// up to level+count for the last used variable.
message New {
  // Includes any uris listed below. This makes it easier to substitute or walk
  // a term.
  sint32 bindCount = 1;
  Par p = 2 [(scalapb.field).no_box = true];
  // For normalization, uri-referenced variables come at the end, and in
  // lexicographical order.
  repeated string uri = 3;
  map<string, Par> injections = 4;
  bytes locallyFree = 5
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];

  // Reified RSpaces: Space type annotations for channels.
  // Syntax: `new x : space_type in { ... }`
  // Each entry corresponds to the space type for that channel index (parallel to uri).
  // Empty/None entries indicate no space type (use default space).
  // Contains the normalized Par representation of the space name expression.
  repeated Par space_types = 6;
}

/**
 * UseBlock for scoped default space selection (Reifying RSpaces).
 *
 * Syntax: `use space_expr { body }`
 *
 * When evaluated, the space expression determines the default space
 * for all operations within the body. UseBlocks can be nested, forming
 * a stack of active spaces (UseBlockStack).
 *
 * Formal Correspondence:
 * - Registry/Invariants.v: inv_use_blocks_valid invariant
 * - GenericRSpace.v: UseBlock scope management
 * - Safety/Properties.v: seq_is_sequential (Seq channels require UseBlock scope)
 */
message UseBlock {
  // The space expression (evaluated to determine target space)
  Par space = 1 [(scalapb.field).no_box = true];
  // The body process to execute within the space scope
  Par body = 2 [(scalapb.field).no_box = true];
  // Free variables in this UseBlock
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  // Whether connectives are used in patterns
  bool connective_used = 4;
}

message MatchCase {
  Par pattern = 1 [(scalapb.field).no_box = true];
  Par source = 2 [(scalapb.field).no_box = true];
  int32 freeCount = 3;
}

message Match {
  Par target = 1 [(scalapb.field).no_box = true];
  repeated MatchCase cases = 2;
  bytes locallyFree = 4
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 5;
}

// Any process may be an operand to an expression.
// Only processes equivalent to a ground process of compatible type will reduce.
message Expr {
  oneof expr_instance {
    bool g_bool = 1;
    sint64 g_int = 2;
    string g_string = 3;
    string g_uri = 4;
    bytes g_byte_array = 25;

    ENot e_not_body = 5;
    ENeg e_neg_body = 6;
    EMult e_mult_body = 7;
    EDiv e_div_body = 8;
    EPlus e_plus_body = 9;
    EMinus e_minus_body = 10;
    ELt e_lt_body = 11;
    ELte e_lte_body = 12;
    EGt e_gt_body = 13;
    EGte e_gte_body = 14;
    EEq e_eq_body = 15;
    ENeq e_neq_body = 16;
    EAnd e_and_body = 17;
    EOr e_or_body = 18;
    EVar e_var_body = 19;

    EList e_list_body = 20;
    ETuple e_tuple_body = 21;
    ESet e_set_body = 22 [(scalapb.field).type = "coop.rchain.models.ParSet"];
    EMap e_map_body = 23 [(scalapb.field).type = "coop.rchain.models.ParMap"];
    EMethod e_method_body = 24;
    EPathMap e_pathmap_body = 32;
    EZipper e_zipper_body = 33;

    EMatches e_matches_body = 27;
    EPercentPercent e_percent_percent_body = 28;  // string interpolation
    EPlusPlus e_plus_plus_body = 29;              // concatenation
    EMinusMinus e_minus_minus_body = 30;          // set difference

    EMod e_mod_body = 31;

    EFree e_free_body = 34;  // theory specification marker for space construction
    EFunction e_function_body = 35;  // built-in function call: getSpaceAgent(space), etc.
  }
}

message EList {
  repeated Par ps = 1;
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 4;
  Var remainder = 5;
}

message ETuple {
  repeated Par ps = 1;
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 4;
}

message ESet {
  repeated Par ps = 1;
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 4;
  Var remainder = 5;
}

message EMap {
  repeated KeyValuePair kvs = 1;
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 4;
  Var remainder = 5;
}

message EPathMap {
  repeated Par ps = 1;
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 4;
  Var remainder = 5;
}

/**
 * Zipper for navigating and modifying PathMaps.
 * Zippers maintain a focus position within a PathMap structure,
 * allowing efficient navigation and modification operations.
 */
message EZipper {
  // The underlying PathMap being navigated
  EPathMap pathmap = 1;
  
  // Current path position in the zipper (list of path segments as bytes)
  // Each segment is encoded as bytes representing a Par value
  repeated bytes current_path = 2;
  
  // Whether this is a write zipper (true) or read zipper (false)
  bool is_write_zipper = 3;

  // Metadata from the PathMap
  bytes locallyFree = 4
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 5;
}

/**
 * EFree marks a theory specification for space construction.
 * Used in expressions like: HMB!?("default", free "Nat")
 * The body contains the theory name (string) or expression.
 *
 * Builtin theories: Nat, Int, String, Bool, Any
 * MeTTaIL theories: mettail:path/to/theory.metta
 */
message EFree {
  Par body = 1;
}

/**
 * `target.method(arguments)`
 */
message EMethod {
  string methodName = 1;
  Par target = 2 [(scalapb.field).no_box = true];
  repeated Par arguments = 3;
  bytes locallyFree = 5
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 6;
}

/**
 * Built-in function call: `functionName(arguments)`
 *
 * Enables synchronous function-style calls for built-in operations like:
 * - getSpaceAgent(space) - returns the factory URN that created a space
 *
 * Unlike methods (target.method), functions operate without a receiver.
 */
message EFunction {
  string function_name = 1;
  repeated Par arguments = 2;
  bytes locallyFree = 3
      [(scalapb.field).type =
           "coop.rchain.models.AlwaysEqual[scala.collection.immutable.BitSet]"];
  bool connective_used = 4;
}

message KeyValuePair {
  Par key = 1 [(scalapb.field).no_box = true];
  Par value = 2 [(scalapb.field).no_box = true];
}

// A variable used as a var should be bound in a process context, not a name
// context. For example:
// `for (@x <- c1; @y <- c2) { z!(x + y) }` is fine, but
// `for (x <- c1; y <- c2) { z!(x + y) }` should raise an error.
message EVar {
  Var v = 1 [(scalapb.field).no_box = true];
}

message ENot {
  Par p = 1 [(scalapb.field).no_box = true];
}

message ENeg {
  Par p = 1 [(scalapb.field).no_box = true];
}

message EMult {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EDiv {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EMod {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EPlus {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EMinus {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message ELt {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message ELte {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EGt {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EGte {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EEq {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message ENeq {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EAnd {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EOr {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message EMatches {
  Par target = 1 [(scalapb.field).no_box = true];
  Par pattern = 2 [(scalapb.field).no_box = true];
}

/**
 * String interpolation
 *
 * `"Hello, {name}" %% {"name": "Bob"}` denotes `"Hello, Bob"`
 */
message EPercentPercent {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

// Concatenation
message EPlusPlus {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

// Set difference
message EMinusMinus {
  Par p1 = 1 [(scalapb.field).no_box = true];
  Par p2 = 2 [(scalapb.field).no_box = true];
}

message Connective {
  oneof connective_instance {
    ConnectiveBody conn_and_body = 1;
    ConnectiveBody conn_or_body = 2;
    Par conn_not_body = 3;
    VarRef var_ref_body = 4;
    bool conn_bool = 5;
    bool conn_int = 6;
    bool conn_string = 7;
    bool conn_uri = 8;
    bool conn_byte_array = 9;
  }
}

message VarRef {
  sint32 index = 1;
  sint32 depth = 2;
}

message ConnectiveBody {
  repeated Par ps = 1;
}

message DeployId {
  bytes sig = 1;
}

message DeployerId {
  bytes publicKey = 1;
}

// Unforgeable names resulting from `new x { ... }`
// These should only occur as the program is being evaluated. There is no way in
// the grammar to construct them.
message GUnforgeable {
  oneof unf_instance {
    GPrivate g_private_body = 1;
    GDeployId g_deploy_id_body = 2;
    GDeployerId g_deployer_id_body = 3;
    GSysAuthToken g_sys_auth_token_body = 4;
  }
}

message GPrivate {
  bytes id = 1;
}

message GDeployId {
  bytes sig = 1;
}

message GDeployerId {
  bytes publicKey = 1;
}

message GSysAuthToken {}

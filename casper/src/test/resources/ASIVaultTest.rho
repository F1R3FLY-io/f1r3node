// Match a list of known valid publicKey -> ASIAddress pairs to bind them to veriables
match (
    "04f700a417754b775d95421973bdbdadb2d23c8a5af46f1829b1431f5c136e549e8a0d61aa0c793f1a614f8e437711c7758473c6ceb0859ac7e9e07911ca66b5c4".hexToBytes(),
    "11112VYAt8rUGNRRZX3eJdgagaAhtWTK8Js7F7X5iqddMVqyDTtYau",
    "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111".hexToBytes(),
    "1111pdZDG4MZ3eBfaipaD22VXmbFY6PW9ZdGDWdEcXZz4gGxTxgn9",
    "2222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222".hexToBytes(),
    "11112CXAkc8pV2AMHUSgHGbFkqovgyY9SRja4ZLSpRC9q7qYZx5SVc"
) {
  (
    genesisPubKey,
    genesisASIAddress, // the rev address of a vault instantiated at genesis
    alicePubKey,
    aliceASIAddress, // the rev address of a vault constructed post-genesis
    bobPubKey,
    bobASIAddress // the rev address of a vault constructed post-genesis
  ) => {

    new
      rl(`rho:registry:lookup`),
      stdlog(`rho:io:stdlog`),
      RhoSpecCh,
      ListOpsCh,
      getDeployerId(`rho:test:deployerId:make`),
      setup,
      testFindOrCreateGenesisVault,
      testDepositToGenesisCreatedVault,
      testBalanceInGenesisCreatedVault,
      testTransferInGenesisCreatedVault,
      testCreateVaultFail,
      testCreateVault,
      testTransfer,
      testFindOrCreate,
      testTransferToSelf,
      testAmountNegative,
      testInsufficeintFunds,
      testInvalidASIAddress,
      testUnfBoundVault,
      testLogging,
      withVaultAndIdentityOf,
      transfer,
      assertBalances
    in {
      rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
      for(@(_, RhoSpec) <- RhoSpecCh) {
        @RhoSpec!("testSuite", *setup,
          [
            ("Create genesis vault with expected balance", *testFindOrCreateGenesisVault),
            ("Return an error for invalid public key", *testCreateVaultFail),
            ("Create vault and see that it is secured", *testCreateVault),
            ("Transfer from genesis to Alice", *testTransfer),
            ("Return the existing wallet when calling testFindOrCreate", *testFindOrCreate),
            ("Transfer to own account successfully", *testTransferToSelf),
            ("Fail the tranfer if the amount to transfer is negative", *testAmountNegative),
            ("Fail the transfer if there are insufficient funds", *testInsufficeintFunds),
            ("Fail the transfer if the destination addresss is not a valid ASIAddress", *testInvalidASIAddress),
            ("Transfer from unforgeable name bound vault", *testUnfBoundVault),
            ("Logging works", *testLogging)
          ])
      } |

      contract setup(_, ret) = {
        new ASIVaultCh in {
          rl!(`rho:rchain:asiVault`, *ASIVaultCh) |
          for (@(_, ASIVault) <- ASIVaultCh) {
            ret!(ASIVault)
          }
        }
      } |

      contract testFindOrCreateGenesisVault(rhoSpec, ASIVault, ackCh) = {
        new genesisVaultCh, balanceCh in {
          ASIVault!("findOrCreate", genesisASIAddress, *genesisVaultCh) |
          for (@(true, genesisVault) <- genesisVaultCh) {
            // so far, access to genesisVault is not secured. This will be changd.
            @genesisVault!("balance", *balanceCh) |
            rhoSpec!("assert", (9000000, "== <-", *balanceCh), "balance is as expected", *ackCh)
          }
        }
      } |

      contract testCreateVaultFail(rhoSpec, ASIVault, ackCh) = {
        new e1 in {
          ASIVault!("findOrCreate", "EEEE", *e1) |
          rhoSpec!("assertMany",
            [
              (((false, "Invalid address length"), "== <-", *e1), "should be a failure")
            ], *ackCh
          )
        }
      } |

      contract testCreateVault(rhoSpec, ASIVault, ackCh) = {
        new aliceVaultCh, deployerId(`rho:rchain:deployerId`), genesisAuthKeyCh, balanceCh, transferCh in {
          ASIVault!("findOrCreate", aliceASIAddress, *aliceVaultCh) |
          //as per `setup`, the deployer is `genesis` and shouldn't be able to access the vault
          ASIVault!("deployerAuthKey", *deployerId, *genesisAuthKeyCh) |
          for (@(true, aliceVault) <- aliceVaultCh & genesisAuthKey <- genesisAuthKeyCh) {
            @aliceVault!("balance", *balanceCh) |
            @aliceVault!("transfer", genesisASIAddress, 1, *genesisAuthKey, *transferCh) |
            rhoSpec!("assertMany",
              [
                ((0, "== <-", *balanceCh), "balance should be 0"),
                (((false, "Invalid AuthKey"), "== <-", *transferCh), "transfer should fail")
              ], *ackCh
            )
          }
        }
      } |

      contract testTransfer(rhoSpec, ASIVault, ackCh) = {
        new genesisVaultCh, aliceVaultCh, ret, transferSuccessful  in {
          withVaultAndIdentityOf!(genesisPubKey, *genesisVaultCh) |
          ASIVault!("findOrCreate", aliceASIAddress, *aliceVaultCh) |
          for (genesisVault, @genesisVaultKey <- genesisVaultCh & @(true, aliceVault) <- aliceVaultCh) {
            genesisVault!("transfer", aliceASIAddress, 1000, genesisVaultKey, *ret) |
            rhoSpec!("assert", ((true, Nil), "== <-", *ret), "transfer successful", *transferSuccessful) |
            assertBalances!(*transferSuccessful, [(*genesisVault, 8999000), (aliceVault, 1000)], *rhoSpec, *ackCh)
          }
        }
      } |

      contract testFindOrCreate(rhoSpec, ASIVault, ackCh) = {
        new genesisVaultCh, aliceVaultCh, now in {
          //the below attempts to create a wallet are going to fetch the ones created in previous tests.
          ASIVault!("findOrCreate", genesisASIAddress, *genesisVaultCh) |
          ASIVault!("findOrCreate", aliceASIAddress, *aliceVaultCh) |
          for (@(true, g) <- genesisVaultCh & @(true, a) <- aliceVaultCh) {
            now!(Nil) |
            assertBalances!(*now, [(g, 8999000), (a, 1000)], *rhoSpec, *ackCh)
          }
        }
      } |

      contract testTransferToSelf(rhoSpec, ASIVault, ackCh) = {
        new aliceVaultCh, now, balanceOk, transferResult, transferOk in {
          withVaultAndIdentityOf!(alicePubKey, *aliceVaultCh) |
          for (@aliceVault, @aliceVaultKey <- aliceVaultCh) {
            now!(Nil) |
            assertBalances!(*now, [(aliceVault, 1000)], *rhoSpec, *balanceOk) |
            transfer!(*balanceOk, aliceVault, aliceASIAddress, 1000, aliceVaultKey, *transferResult) |
            rhoSpec!("assert", ((true, Nil), "== <-", *transferResult), "transfer successful", *transferOk) |
            assertBalances!(*transferOk, [(aliceVault, 1000)], *rhoSpec, *ackCh)
          }
        }
      } |

      contract testAmountNegative(rhoSpec, ASIVault, ackCh) = {
        new aliceVaultCh, now, balanceOk, transferResult, transferOk in {
          withVaultAndIdentityOf!(alicePubKey, *aliceVaultCh) |
          for (@aliceVault, @aliceVaultKey <- aliceVaultCh) {
            now!(Nil) |
            assertBalances!(*now, [(aliceVault, 1000)], *rhoSpec, *balanceOk) |
            transfer!(*balanceOk, aliceVault, bobASIAddress, -1, aliceVaultKey, *transferResult) |
            rhoSpec!("assert", ((false, "Amount must be positive value"), "== <-", *transferResult), "transfer failed", *transferOk) |
            assertBalances!(*transferOk, [(aliceVault, 1000)], *rhoSpec, *ackCh)
          }
        }
      } |

      contract testInsufficeintFunds(rhoSpec, ASIVault, ackCh) = {
        new aliceVaultCh, res, resOk in {
          withVaultAndIdentityOf!(alicePubKey, *aliceVaultCh) |
          for (aliceVault, @aliceVaultKey <- aliceVaultCh) {
            aliceVault!("transfer", bobASIAddress, 9000, aliceVaultKey, *res) |
            rhoSpec!("assert", ((false, "Insufficient funds"), "== <-", *res), "transfer failed", *resOk) |
            assertBalances!(*resOk, [(*aliceVault, 1000)], *rhoSpec, *ackCh)
          }
        }
      } |

      contract testInvalidASIAddress(rhoSpec, ASIVault, ackCh) = {
        new aliceVaultCh, res, resOk in {
          withVaultAndIdentityOf!(alicePubKey, *aliceVaultCh) |
          for (aliceVault, @aliceVaultKey <- aliceVaultCh) {
            aliceVault!("transfer", "pretty surely invalid rev address", 1, aliceVaultKey, *res) |
            rhoSpec!("assert", ((false, "Invalid Base58 encoding"), "== <-", *res), "transfer failed", *resOk) |
            assertBalances!(*resOk, [(*aliceVault, 1000)], *rhoSpec, *ackCh)
          }
        }
      } |

      contract testUnfBoundVault(rhoSpec, ASIVault, ackCh) = {
        new ASIAddress(`rho:asi:address`), deployerId(`rho:rchain:deployerId`),
            unf, unfASIAddrCh, unfAuthKeyCh, unfVaultCh,
            genesisVaultCh, initTransferCh, transferCh
        in {
          withVaultAndIdentityOf!(genesisPubKey, *genesisVaultCh) |
          // Get unforgeable channel REV address
          ASIAddress!("fromUnforgeable", *unf, *unfASIAddrCh) |
          for (@unfASIAddress <- unfASIAddrCh; genesisVault, genesisVaultKey <- genesisVaultCh) {
            // Transfer initial funds to unforgeable vault
            genesisVault!("transfer", unfASIAddress, 100, *genesisVaultKey, *initTransferCh) |
            // Teting transfer from unforgeable bound vault
            ASIVault!("findOrCreate", unfASIAddress, *unfVaultCh) |
            ASIVault!("unforgeableAuthKey", *unf, *unfAuthKeyCh) |
            for (@(true, unfVault) <- unfVaultCh; unfAuthKey <- unfAuthKeyCh; _ <- initTransferCh) {
              @unfVault!("transfer", genesisASIAddress, 1, *unfAuthKey, *transferCh) |
              rhoSpec!("assert", ((true, Nil), "== <-", *transferCh), "transfer succeeded", *ackCh)
            }
          }
        }
      } |

      contract testLogging(rhoSpec, ASIVault, ackCh) = {
        new genesisVaultCh, aliceVaultCh, ret, transferSuccessful  in {
          withVaultAndIdentityOf!(genesisPubKey, *genesisVaultCh) |
          ASIVault!("findOrCreate", aliceASIAddress, *aliceVaultCh) |
          for (genesisVault, @genesisVaultKey <- genesisVaultCh & @(true, aliceVault) <- aliceVaultCh) {
            new ack, logCh, assertCh1, assertCh2 in {
              genesisVault!("setLog", *logCh, genesisVaultKey, *ack) |
              for (_ <- ack) {
                genesisVault!("transfer", aliceASIAddress, 1000, genesisVaultKey, *ret) |
                for (@["transfer", asiAddress, amount, result, blockNumber, timestamp, sender] <- logCh) {
                  rhoSpec!("assert",
                    ([aliceASIAddress, 1000, (true, Nil)] == [asiAddress, amount, result]),
                    "transfer successfully logged",
                    *ackCh)
                }
              }
            }
          }
        }
      } |

      new ASIVaultCh in {
        rl!(`rho:rchain:asiVault`, *ASIVaultCh) |
        for (@(_, ASIVault) <- ASIVaultCh) {

          contract withVaultAndIdentityOf(@pubKey, ret) = {
            new ASIAddress(`rho:asi:address`), asiAddrCh, vaultCh, deployerIdCh, authKeyCh in {
              getDeployerId!("deployerId", pubKey, *deployerIdCh) |
              ASIAddress!("fromPublicKey", pubKey, *asiAddrCh) |
              for (@asiAddr <- asiAddrCh) {
                @ASIVault!("findOrCreate", asiAddr, *vaultCh) |
                for (@(true, vault) <- vaultCh & deployerId <- deployerIdCh) {
                  @ASIVault!("deployerAuthKey", *deployerId, *authKeyCh) |
                  for (@authKey <- authKeyCh) {
                    ret!(vault, authKey)
                  }
                }
              }
            }
          }

        }
      } |

      contract transfer(when, vault, @address, @amount, authKey, ret) = {
        for (_ <- when) {
          vault!("transfer", address, amount, *authKey, *ret)
        }
      } |

      rl!(`rho:lang:listOps`, *ListOpsCh) |
      for(@(_, ListOps) <- ListOpsCh) {

        contract assertBalances(when, @balances, rhoSpec, ret) = {
          for (_ <- when) {
            new assertBalance in {
              @ListOps!("foreach", balances, *assertBalance, *ret) |

              contract assertBalance(@(vault, expectedBalance), retCh) = {
                new balanceCh in {
                  @vault!("balance", *balanceCh) |
                  rhoSpec!("assert", (expectedBalance, "== <-", *balanceCh), "balance is as expected", *retCh)
                }
              }
            }
          }
        }

      }
    }
  }
}

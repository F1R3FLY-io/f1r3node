new
  rl(`rho:registry:lookup`), RhoSpecCh,
  test_newline_escape, test_tab_escape, test_quote_escape,
  test_backslash_escape, test_unicode_escape, test_combined_escapes,
  test_no_escape_needed
in {
  rl!(`rho:id:zphjgsfy13h1k85isc8rtwtgt3t9zzt5pjd5ihykfmyapfc4wt3x5h`, *RhoSpecCh) |
  for(@(_, RhoSpec) <- RhoSpecCh) {
    @RhoSpec!("testSuite",
      [
        ("Newline escape sequences are unescaped correctly", *test_newline_escape),
        ("Tab escape sequences are unescaped correctly", *test_tab_escape),
        ("Quote escape sequences are unescaped correctly", *test_quote_escape),
        ("Backslash escape sequences are unescaped correctly", *test_backslash_escape),
        ("Unicode escape sequences are unescaped correctly", *test_unicode_escape),
        ("Combined escape sequences are unescaped correctly", *test_combined_escapes),
        ("Strings without escapes remain unchanged", *test_no_escape_needed)
      ])
  } |

  contract test_newline_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Hello\nWorld") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Hello\nWorld", "==", msg), "Newline escaped string unescaped correctly", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "Newline test completed", *ackCh)
        }
      }
    }
  } |

  contract test_tab_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Column1\tColumn2") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Column1\tColumn2", "==", msg), "Tab escaped string unescaped correctly", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "Tab test completed", *ackCh)
        }
      }
    }
  } |

  contract test_quote_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("She said \"Hello\"") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("She said \"Hello\"", "==", msg), "Quote escaped string unescaped correctly", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "Quote test completed", *ackCh)
        }
      }
    }
  } |

  contract test_backslash_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Path: C:\\Users\\Documents") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Path: C:\\Users\\Documents", "==", msg), "Backslash escaped string unescaped correctly", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "Backslash test completed", *ackCh)
        }
      }
    }
  } |

  contract test_unicode_escape(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Hello\u0020World") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Hello World", "==", msg), "Unicode escaped string unescaped correctly", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "Unicode test completed", *ackCh)
        }
      }
    }
  } |

  contract test_combined_escapes(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("Line1\nTab\tQuote\"Backslash\\End") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("Line1\nTab\tQuote\"Backslash\\End", "==", msg), "Multiple escape sequences handled correctly", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "Combined escapes test completed", *ackCh)
        }
      }
    }
  } |

  contract test_no_escape_needed(rhoSpec, _, ackCh) = {
    new ch, privateAck in {
      ch!("SimpleStringWithoutEscapes") |
      for (@msg <- ch) {
        rhoSpec!("assert", ("SimpleStringWithoutEscapes", "==", msg), "String without escapes passes through unchanged", *privateAck) |
        for( _ <- privateAck) {
          rhoSpec!("assert", (true, "==", true), "No escape test completed", *ackCh)
        }
      }
    }
  }
}

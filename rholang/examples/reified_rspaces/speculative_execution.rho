// Speculative Execution: Checkpoints and Rollback
//
// Demonstrates speculative execution with checkpoints and rollback.
// Operations can be tentatively executed and then either committed or rolled back.
//
// Key insight: This example uses sequential cell patterns to manage state,
// which IS the correct approach for transactional semantics. Each operation
// explicitly sequences after the previous one via the cell read-update pattern.
//
// This is NOT about non-deterministic execution order - it's about providing
// the ability to revert state changes when a transaction fails.
//
// Use Cases:
//   - Database transactions (commit/rollback)
//   - Optimistic concurrency control
//   - Two-phase commit protocols
//   - Undo functionality
//
// Run: rholang-cli eval speculative_execution.rho

new stdout(`rho:io:stdout`) in {

  // Create a space for transactional operations
  new BankFactory(`rho:space:bag:hashmap:default`), bank in {
    BankFactory!("default", Nil, *bank) |

    for (space <- bank) {
      stdout!("Bank space created") |

      use space {
        new account, transfer, commit, rollback in {

          // Initialize account balance
          account!({"balance": 1000, "version": 0}) |

          // Transfer contract: performs speculative update
          contract transfer(@amount, @toAccount, checkpoint, ack) = {
            for (@state <- account) {
              // Save checkpoint for potential rollback
              checkpoint!(state) |

              // Perform speculative update
              if (state.get("balance") >= amount) {
                account!({"balance": state.get("balance") - amount,
                          "version": state.get("version") + 1}) |
                stdout!(["Transfer:", amount, "| Balance:", state.get("balance") - amount]) |
                ack!(true)
              } else {
                // Insufficient funds - rollback immediately
                account!(state) |
                stdout!(["Transfer FAILED: insufficient funds for", amount]) |
                ack!(false)
              }
            }
          } |

          // Commit contract: discards checkpoint, keeping changes
          contract commit(checkpoint, ack) = {
            for (_ <- checkpoint) {
              stdout!("Transaction committed") |
              ack!(Nil)
            }
          } |

          // Rollback contract: restores checkpoint, discarding changes
          contract rollback(checkpoint, ack) = {
            for (@saved <- checkpoint) {
              for (_ <- account) {  // Discard current state
                account!(saved) |
                stdout!(["Rolled back to balance:", saved.get("balance")]) |
                ack!(Nil)
              }
            }
          } |

          // Demo: successful transaction
          new cp1, ack1 in {
            transfer!(200, "external", *cp1, *ack1) |
            for (@success <- ack1) {
              if (success) {
                new ackCommit in {
                  commit!(*cp1, *ackCommit) |
                  for (_ <- ackCommit) {
                    // Continue with next transaction
                    new cp2, ack2 in {
                      // Demo: transaction that gets rolled back
                      transfer!(500, "external", *cp2, *ack2) |
                      for (@success2 <- ack2) {
                        if (success2) {
                          // Simulate business logic failure - rollback
                          stdout!("Business validation failed - rolling back") |
                          new ackRollback in {
                            rollback!(*cp2, *ackRollback) |
                            for (_ <- ackRollback) {
                              // Final balance check
                              for (@finalState <- account) {
                                account!(finalState) |
                                stdout!(["Final balance:", finalState.get("balance")])
                              }
                            }
                          }
                        } else {
                          Nil
                        }
                      }
                    }
                  }
                }
              } else {
                Nil
              }
            }
          }
        }
      }
    }
  } |

  // Simpler checkpoint/rollback pattern

  new counter, makeCheckpoint, restoreCheckpoint in {

    counter!(0) |

    // Checkpoint management contracts
    contract makeCheckpoint(checkpointCell) = {
      for (@value <- counter) {
        counter!(value) |  // Put back current value
        checkpointCell!(value) |
        stdout!(["Checkpoint created at:", value])
      }
    } |

    contract restoreCheckpoint(checkpointCell) = {
      for (@saved <- checkpointCell) {
        for (_ <- counter) {  // Discard current
          counter!(saved) |
          stdout!(["Restored to checkpoint:", saved])
        }
      }
    } |

    // Demo sequence: increment, checkpoint, increment more, rollback
    new ack1 in {
      // Increment to 5
      for (@v <- counter) { counter!(5) | ack1!(Nil) } |
      for (_ <- ack1) {
        stdout!(["Counter is now:", 5]) |
        // Checkpoint and rollback demo:
        new checkpoint in {
          for (@v <- counter) {
            checkpoint!(v) |
            counter!(v + 10) |  // Speculative change
            stdout!(["After speculative change:", v + 10]) |

            // Decide to rollback
            for (@saved <- checkpoint) {
              for (_ <- counter) {
                counter!(saved) |
                stdout!(["Rolled back to:", saved])
              }
            }
          }
        }
      }
    }
  } |

  // Optimistic concurrency control demo

  new data, update in {

    // Data with version number
    data!({"value": "initial", "version": 1}) |

    // Optimistic update: only succeeds if version matches
    contract update(@expectedVersion, @newValue, ack) = {
      for (@current <- data) {
        if (current.get("version") == expectedVersion) {
          // Version matches - update succeeds
          data!({"value": newValue, "version": expectedVersion + 1}) |
          stdout!(["Update succeeded:", newValue, "v", expectedVersion + 1]) |
          ack!(true)
        } else {
          // Version mismatch - concurrent modification detected
          data!(current) |  // Put back unchanged
          stdout!(["Update FAILED: version mismatch (expected", expectedVersion,
                   ", got", current.get("version"), ")"]) |
          ack!(false)
        }
      }
    } |

    // Concurrent updates - only one should succeed
    new ack1, ack2 in {
      update!(1, "from-client-A", *ack1) |
      update!(1, "from-client-B", *ack2) |

      for (@r1 <- ack1; @r2 <- ack2) {
        for (@finalData <- data) {
          data!(finalData) |
          stdout!(["Final state:", finalData])
        }
      }
    }
  }
}

// Expected Output:
// === Transactional State Demo ===
// Bank space created
// [Transfer:, 200, | Balance:, 800]
// Transaction committed
// [Transfer:, 500, | Balance:, 300]
// Business validation failed - rolling back
// [Rolled back to balance:, 800]
// [Final balance:, 800]
//
// === Simple Checkpoint Demo ===
// [Counter is now:, 5]
// [After speculative change:, 15]
// [Rolled back to:, 5]
//
// === Optimistic Concurrency Demo ===
// [Update succeeded:, from-client-A, v, 2]
// [Update FAILED: version mismatch (expected, 1, , got, 2, )]
// [Final state:, {value: "from-client-A", version: 2}]
//
// Note: Transactional patterns use explicit sequencing (cell patterns)
// to ensure correct state management. The sequential acknowledgment
// pattern is appropriate here - it's NOT about non-determinism, it's
// about providing rollback capabilities for failed operations.

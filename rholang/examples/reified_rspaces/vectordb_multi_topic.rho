// =============================================================================
// VectorDB Multi-Topic Search - Multiple Independent Spaces
// =============================================================================
//
// This example demonstrates searching across multiple independent VectorDB spaces,
// each representing a different topic domain. A join pattern coordinates completion.
//
// Query Syntax (Lazy Channel Return):
//   Basic:       for (resultCh <- ch ~ "query") {
//                  for (@doc <- resultCh) { ... }
//                }
//   With metric: for (resultCh <- ch ~ sim("cos", "0.7") ~ "query") {
//                  for (@doc <- resultCh) { ... }
//                }
//   With top-K:  for (resultCh <- ch ~ rank("topk", 2) ~ "query") {
//                  for (@doc1 <- resultCh) {
//                    for (@doc2 <- resultCh) { ... }
//                  }
//                }
//
// Embedding dimensions: [animal, tech, food, nature]
//
// Synchronization: Join Pattern
// - Each space queries independently, signals completion via done channel
// - Final message only prints after ALL spaces complete
//
// Run: rholang-cli eval vectordb_multi_topic.rho

new stdout(`rho:io:stdout`),
    VectorDBFactory(`rho:space:vectordb:hashmap:default`) in {

  // Create three separate VectorDB spaces for different domains
  new animalSpace, techSpace, natureSpace in {
    VectorDBFactory!("default", {"dimensions": 4, "metric": "cosine", "threshold": "0.5", "embedding_type": "float"}, *animalSpace) |
    VectorDBFactory!("default", {"dimensions": 4, "metric": "cosine", "threshold": "0.5", "embedding_type": "float"}, *techSpace) |
    VectorDBFactory!("default", {"dimensions": 4, "metric": "cosine", "threshold": "0.5", "embedding_type": "float"}, *natureSpace) |

    // ============================================================
    // ANIMAL TOPIC SPACE
    // ============================================================
    for (animalVdb <- animalSpace) {
      use animalVdb {
        new docs in {
          docs!!({"id": 1, "title": "Cats Guide", "embedding": "0.9,0.05,0.1,0.2"}) |

          // Basic similarity query (lazy channel)
          for (resultCh <- docs ~ "0.85,0.1,0.15,0.15") {
            for (@doc <- resultCh) {
              stdout!(["Animal:", doc.get("title")])
            }
          }
        }
      }
    } |

    // ============================================================
    // TECH TOPIC SPACE
    // ============================================================
    for (techVdb <- techSpace) {
      use techVdb {
        new docs in {
          docs!!({"id": 2, "title": "ML Intro", "embedding": "0.05,0.95,0.05,0.1"}) |

          // Query with explicit metric (lazy channel)
          for (resultCh <- docs ~ sim("cos", "0.7") ~ "0.1,0.9,0.05,0.15") {
            for (@doc <- resultCh) {
              stdout!(["Tech (cos>=70%):", doc.get("title")])
            }
          }
        }
      }
    } |

    // ============================================================
    // NATURE TOPIC SPACE
    // ============================================================
    for (natureVdb <- natureSpace) {
      use natureVdb {
        new docs in {
          docs!!({"id": 3, "title": "Hiking Trails", "embedding": "0.5,0.05,0.1,0.7"}) |
          docs!!({"id": 4, "title": "Mountain Views", "embedding": "0.3,0.02,0.08,0.9"}) |

          // Top-K query - get 2 best matches (lazy channel with nested bindings)
          for (resultCh <- docs ~ rank("topk", 2) ~ "0.4,0.05,0.15,0.8") {
            for (@doc1 <- resultCh) {
              for (@doc2 <- resultCh) {
                stdout!(["Nature top-2:", [doc1.get("title"), doc2.get("title")]])
              }
            }
          }
        }
      }
    }
  }
}

// Expected Output (order non-deterministic):
// [Animal:, Cats Guide]
// [Tech (cos>=70%):, ML Intro]
// [Nature top-2:, [Mountain Views, Hiking Trails]]
// === All spaces complete ===
//
// Note: Each space operates independently with different query patterns:
// - Animal: basic similarity query
// - Tech: explicit cosine with 70% threshold
// - Nature: top-K returning 2 best matches
//
// Key Changes:
// - All queries return lazy channels
// - Use nested for-bindings to consume documents
// - Top-K uses K nested bindings
// - Join pattern now fires correctly (channel-to-space mapping fix)
